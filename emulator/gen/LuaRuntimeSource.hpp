// Autogenerated file (Do not edit)

#pragma once

constexpr char LUA_RUNTIME_SOURCE[] =
	"-- Runtime features that are easier to implement in Lua\n"
	"\n"
	"-- Hints for IDE, will always actually be populated before this is loaded\n"
	"playdate = playdate or {}\n"
	"\n"
	"-- Local copies for efficiency\n"
	"local geometry = playdate.geometry\n"
	"local graphics = playdate.graphics\n"
	"\n"
	"-- Initialize defaults for optional libraries\n"
	"spritelib = spritelib or {}\n"
	"graphics.nineSlice = graphics.nineSlice or {}\n"
	"\n"
	"-- Create global table for emulator data\n"
	"cranked = {\n"
	"    printNewlines = true,\n"
	"    inputHandlers = { { handler = playdate, masks = false } },\n"
	"    menuCallbacks = {},\n"
	"    references = {}, -- Mapping of native resources to owner tables for internally used resources\n"
	"    updateThread = nil,\n"
	"}\n"
	"\n"
	"playdate.argv = {}\n"
	"\n"
	"function cranked.dispatchInputEvent(name, change, acceleratedChange)\n"
	"    local handlers\n"
	"    handlers = cranked.inputHandlers\n"
	"    local count = #handlers\n"
	"    local handled = false\n"
	"    for i = 1, count do\n"
	"        local handlerTable = handlers[count - i + 1]\n"
	"        local handler = handlerTable.handler\n"
	"        local masks = handlerTable.masks\n"
	"        if handler[name] then\n"
	"            handler[name](change, acceleratedChange) -- Extra args are nil anyway when unused\n"
	"            if masks then\n"
	"                return true\n"
	"            end\n"
	"        end\n"
	"    end\n"
	"    return handled\n"
	"end\n"
	"\n"
	"-- Overwrite default print functionality with ability to control newlines\n"
	"function print(...)\n"
	"    local write = io.write\n"
	"    local n = select(\"#\", ...)\n"
	"    for i = 1, n do\n"
	"        local v = tostring(select(i, ...))\n"
	"        write(v)\n"
	"        if i ~= n then\n"
	"            write('\\t')\n"
	"        end\n"
	"    end\n"
	"    if cranked.printNewlines then\n"
	"        write('\\n')\n"
	"    end\n"
	"end\n"
	"\n"
	"function table.indexOfElement(table, element)\n"
	"    for k, v in ipairs(table) do\n"
	"        if v == element then\n"
	"            return k\n"
	"        end\n"
	"    end\n"
	"    return nil\n"
	"end\n"
	"\n"
	"-- Not sure of an easy way to get size of the hash portion, so iterating it is...\n"
	"function table.getSize(table)\n"
	"    local count = 0\n"
	"    for _ in pairs(table) do\n"
	"        count = count + 1\n"
	"    end\n"
	"    local arraySize = #table\n"
	"    return arraySize, count - arraySize\n"
	"end\n"
	"\n"
	"function table.shallowcopy(source, destination)\n"
	"    if destination == nil then\n"
	"        destination = {}\n"
	"    end\n"
	"    for k, v in pairs(source) do\n"
	"        destination[k] = v\n"
	"    end\n"
	"    return destination\n"
	"end\n"
	"\n"
	"function table.deepcopy(source)\n"
	"    local destination, tables, tab -- Separate lines to fool dumb, broken IDE plugin\n"
	"    tab = table\n"
	"    destination = {}\n"
	"    tables = {} -- Cache copies to avoid infinite recursion\n"
	"    for k, v in pairs(source) do\n"
	"        if type(v) == 'table' then\n"
	"            if tables[v] then\n"
	"                destination[k] = tables[v]\n"
	"            else\n"
	"                local t = tab.deepcopy(v)\n"
	"                tables[v] = t\n"
	"                destination[k] = t\n"
	"            end\n"
	"        else\n"
	"            destination[k] = v\n"
	"        end\n"
	"    end\n"
	"    return destination\n"
	"end\n"
	"\n"
	"function playdate.setNewlinePrinted(flag)\n"
	"    cranked.printNewlines = flag\n"
	"end\n"
	"\n"
	"-- Accelerometer control not needed\n"
	"function playdate.startAccelerometer() end\n"
	"function playdate.stopAccelerometer() end\n"
	"\n"
	"function playdate.accelerometerIsRunning()\n"
	"    return true -- Hopefully nothing relies on this actually changing\n"
	"end\n"
	"\n"
	"-- Ignore GC control\n"
	"function playdate.setCollectsGarbage() end\n"
	"function playdate.setMinimumGCTime() end\n"
	"function playdate.setGCScaling() end\n"
	"\n"
	"-- Simulator-only\n"
	"function playdate.clearConsole() end\n"
	"function playdate.setDebugDrawColor() end\n"
	"\n"
	"function playdate.inputHandlers.push(handler, masks)\n"
	"    if masks == nil then\n"
	"        masks = false\n"
	"    end\n"
	"    local handlers\n"
	"    handlers = cranked.inputHandlers\n"
	"    handlers[#handlers + 1] = { handler = handler, masks = masks }\n"
	"end\n"
	"\n"
	"function playdate.inputHandlers.pop()\n"
	"    local handlers\n"
	"    handlers = cranked.inputHandlers\n"
	"    local count = #handlers\n"
	"    if count > 1 then\n"
	"        handlers[count] = nil\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect.new(x, y, width, height)\n"
	"    local rect = {x = x + .0, y = y + .0, width = width + .0, height = height + .0}\n"
	"    setmetatable(rect, geometry.rect)\n"
	"    return rect\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:copy()\n"
	"    return geometry.rect.new(self.x, self.y, self.width, self.height)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:toPolygon()\n"
	"    local rect = geometry.polygon.new(\n"
	"            self.x, self.y,\n"
	"            self.x + self.width, self.y,\n"
	"            self.x + self.width, self.y + self.height,\n"
	"            self.x, self.y + self.height\n"
	"    )\n"
	"    rect:close()\n"
	"    return rect\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:unpack()\n"
	"    return self.x, self.y, self.width, self.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:isEmpty()\n"
	"    return self.width == 0 or self.height == 0\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:isEqual(r2)\n"
	"    return self.x == r2.x and self.y == r2.y and self.width == r2.width and self.height == r2.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:intersects(r2)\n"
	"    return not ((r2.x + r2.width < self.x and r2.y + r2.height < self.y) or (r2.x > self.x + self.width and r2.y > self.y + self.height))\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:intersection(r2)\n"
	"    local rect = geometry.rect.new(0, 0, 0, 0)\n"
	"    if (r2.x > self.x) then\n"
	"        rect.x = r2.x\n"
	"        rect.width = math.max(0, math.min(r2.width, self.width - (r2.x - self.x)))\n"
	"    else\n"
	"        rect.x = self.x\n"
	"        rect.width = math.max(0, math.min(self.width, r2.width - (self.x - r2.x)))\n"
	"    end\n"
	"    if (r2.y > self.y) then\n"
	"        rect.y = r2.y\n"
	"        rect.height = math.max(0, math.min(r2.height, self.height - (r2.y - self.y)))\n"
	"    else\n"
	"        rect.y = self.y\n"
	"        rect.height = math.max(0, math.min(self.height, r2.height - (self.y - r2.y)))\n"
	"    end\n"
	"    return rect\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect.fast_intersection(x1, y1, w1, h1, x2, y2, w2, h2)\n"
	"    local x, y, width, height\n"
	"    if (x2 > x1) then\n"
	"        x = x2\n"
	"        height = math.max(0, math.min(w2, w1 - (x2 - x1)))\n"
	"    else\n"
	"        x = x1\n"
	"        width = math.max(0, math.min(w1, w2 - (x1 - x2)))\n"
	"    end\n"
	"    if (y2 > y1) then\n"
	"        y = y2\n"
	"        height = math.max(0, math.min(h2, h1 - (y2 - y1)))\n"
	"    else\n"
	"        y = y1\n"
	"        height = math.max(0, math.min(h1, h2 - (y1 - y2)))\n"
	"    end\n"
	"    return x, y, width, height\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:union(r2)\n"
	"    return geometry.rect.new(math.min(self.x, r2.x), math.min(self.y, r2.y),\n"
	"            math.max(self.x + self.width, r2.x + r2.width), math.max(self.y + self.height, r2.y + r2.height))\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect.fast_union(x1, y1, w1, h1, x2, y2, w2, h2)\n"
	"    return math.min(x1, x2), math.min(y1, y2), math.max(x1 + w1, x2 + w2), math.max(y1 + h1, y2 + h2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:inset(dx, dy)\n"
	"    self.x = self.x + dx\n"
	"    self.y = self.y + dy\n"
	"    self.width = self.width - dx * 2\n"
	"    self.height = self.height - dy * 2\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:insetBy(dx, dy)\n"
	"    return geometry.rect.new(self.x + dx, self.y + dy, self.width - dx * 2, self.height - dy * 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:offset(dx, dy)\n"
	"    self.x = self.x + dx\n"
	"    self.y = self.y + dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:offsetBy(dx, dy)\n"
	"    return geometry.rect.new(self.x + dx, self.y + dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:containsRect(r2)\n"
	"    return r2.x >= self.x and r2.y >= self.y and r2.x + r2.width <= self.x + self.width and r2.y + r2.height <= self.y + self.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:containsPoint(x, y)\n"
	"    if type(x) == 'number' then\n"
	"        return x >= self.x and y >= self.y and x <= self.x + self.width and y <= self.y + self.height\n"
	"    else\n"
	"        local p = x\n"
	"        return p.x >= self.x and p.y >= self.y and p.x <= self.x + self.width and p.y <= self.y + self.height\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:centerPoint()\n"
	"    return geometry.point.new(self.x + self.width / 2, self.y + self.height / 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:flipRelativeToRect(r2, flip)\n"
	"    if flip == geometry.kFlippedX or flip == geometry.kFlippedXY then\n"
	"        self.x = r2.x * 2 + r2.width - self.x - self.width\n"
	"    end\n"
	"    if flip == geometry.kFlippedY or flip == geometry.kFlippedXY then\n"
	"        self.y = r2.y * 2 + r2.height - self.y - self.height\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:__eq(other)\n"
	"    return self.x == other.x and self.y == other.y and self.width == other.width and self.height == other.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:__tostring()\n"
	"    return string.format('(%s, %s, %s, %s)', self.x, self.y, self.width, self.height)\n"
	"end\n"
	"\n"
	"function playdate.geometry.rect:__index(key)\n"
	"    if key == 'top' then\n"
	"        return self.y\n"
	"    elseif key == 'bottom' then\n"
	"        return self.y + self.height\n"
	"    elseif key == 'right' then\n"
	"        return self.x + self.width\n"
	"    elseif key == 'left' then\n"
	"        return self.x\n"
	"    elseif key == 'origin' then\n"
	"        return geometry.point.new(self.x, self.y)\n"
	"    elseif key == 'size' then\n"
	"        return geometry.size.new(self.width, self.height)\n"
	"    else\n"
	"        return geometry.rect[key]\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.point.new(x, y)\n"
	"    local rect = {x = x + .0, y = y + .0}\n"
	"    setmetatable(rect, geometry.point)\n"
	"    return rect\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:copy()\n"
	"    return geometry.point.new(self.x, self.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:unpack()\n"
	"    return self.x, self.y\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:offset(dx, dy)\n"
	"    self.x = self.x + dx\n"
	"    self.y = self.y + dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:offsetBy(dx, dy)\n"
	"    return geometry.point.new(self.x + dx, self.y + dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:squaredDistanceToPoint(p)\n"
	"    return (self.x - p.x) ^ 2 + (self.y - p.y) ^ 2\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:distanceToPoint(p)\n"
	"    return math.sqrt((self.x - p.x) ^ 2 + (self.y - p.y) ^ 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__tostring()\n"
	"    return string.format('(%s, %s)', self.x, self.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__eq(p)\n"
	"    return self.x == p.x and self.y == p.y\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__add(v)\n"
	"    return geometry.point.new(self.x + v.dx, self.y + v.dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__sub(p)\n"
	"    return geometry.vector.new(self.x - p.x, self.y - p.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__mul(t)\n"
	"    return t:transformedPoint(self)\n"
	"end\n"
	"\n"
	"function playdate.geometry.point:__concat(p)\n"
	"    return geometry.lineSegment.new(self.x, self.y, p.x, p.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.size.new(width, height)\n"
	"    local rect = {width = width + .0, height = height + .0}\n"
	"    setmetatable(rect, geometry.size)\n"
	"    return rect\n"
	"end\n"
	"\n"
	"function playdate.geometry.size:copy()\n"
	"    return geometry.size.new(self.width, self.height)\n"
	"end\n"
	"\n"
	"function playdate.geometry.size:__tostring()\n"
	"    return string.format('(%s, %s)', self.width, self.height)\n"
	"end\n"
	"\n"
	"function playdate.geometry.size:__eq(other)\n"
	"    return self.width == other.width and self.height == other.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.size:unpack()\n"
	"    return self.width, self.height\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D.new(x, y)\n"
	"    local vector = {dx = x + .0, dy = y + .0}\n"
	"    setmetatable(vector, geometry.vector2D)\n"
	"    return vector\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D.newPolar(length, angle)\n"
	"    local vector = {dx = math.cos(angle - 90) * length, dy = math.sin(angle - 90) * length}\n"
	"    setmetatable(vector, geometry.vector2D)\n"
	"    return vector\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:copy()\n"
	"    return geometry.vector2D.new(self.dx, self.dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:unpack()\n"
	"    return self.dx, self.dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:addVector(v)\n"
	"    self.dx = self.dx + v.dx\n"
	"    self.dy = self.dy + v.dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:scale(s)\n"
	"    self.dx = self.dx * s\n"
	"    self.dy = self.dy * s\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:scaledBy(s)\n"
	"    return geometry.vector2D.new(self.dx * s, self.dy * s)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:normalize()\n"
	"    local length = math.sqrt(self.dx ^ 2 + self.dy ^ 2)\n"
	"    self.dx = self.dx / length\n"
	"    self.dy = self.dy / length\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:dotProduct(v)\n"
	"    return self.dx * v.dx + self.dy * v.dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:magnitude()\n"
	"    return math.sqrt(self.dx ^ 2 + self.dy ^ 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:magnitudeSquared()\n"
	"    return self.dx ^ 2 + self.dy ^ 2\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:projectAlong(v)\n"
	"    local vLen = v:magnitude()\n"
	"    local length = (self.dx * v.dx + self.dy * v.dy) / vLen\n"
	"    self.dx = v.dx / vLen * length\n"
	"    self.dy = v.dy / vLen * length\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:projectedAlong(v)\n"
	"    local copy = self:copy()\n"
	"    copy:projectAlong(v)\n"
	"    return copy\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:angleBetween(v)\n"
	"    return math.atan(v.dy, v.dx) - math.atan(self.dy, self.dx)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__unm()\n"
	"    return geometry.vector2D.new(-self.dx, -self.dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__add(v2)\n"
	"    return geometry.vector2D.new(self.dx + v2.dx, self.dy + v2.dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__sub(v2)\n"
	"    return geometry.vector2D.new(self.dx - v2.dx, self.dy - v2.dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__mul(other)\n"
	"    if type(other) == 'number' then\n"
	"        return geometry.vector2D.new(self.dx * other, self.dy * other)\n"
	"    elseif other.__name == 'playdate.geometry.vector2D' then\n"
	"        return self.dx * other.dx + self.dy * other.dy\n"
	"    else -- Assume transform\n"
	"        local x, y = other:transformXY(self.dx, self.dy)\n"
	"        return geometry.vector2D.new(x, y)\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__div(s)\n"
	"    return geometry.vector2D.new(self.dx / s, self.dy / s)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:leftNormal()\n"
	"    return geometry.vector2D.new(self.dy, -self.dx)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:rightNormal()\n"
	"    return geometry.vector2D.new(-self.dy, self.dx)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__tostring()\n"
	"    return string.format('(%s, %s)', self.x, self.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__eq(other)\n"
	"    return self.dx == other.dx and self.dy == other.dy\n"
	"end\n"
	"\n"
	"-- It's not documented, but x and y resolve to dx and dy, respectively\n"
	"function playdate.geometry.vector2D:__index(key)\n"
	"    if key == 'x' then\n"
	"        return self.dx\n"
	"    elseif key == 'y' then\n"
	"        return self.dy\n"
	"    else\n"
	"        return geometry.vector2D[key]\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.vector2D:__newindex(key, value)\n"
	"    if key == 'x' then\n"
	"        self.dx = value + .0\n"
	"    elseif key == 'y' then\n"
	"        self.dy = value + .0\n"
	"    else\n"
	"        self[key] = value\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment.new(x1, y1, x2, y2)\n"
	"    local vector = {x1 = x1 + .0, y1 = y1 + .0, x2 = x2 + .0, y2 = y2 + .0}\n"
	"    setmetatable(vector, geometry.lineSegment)\n"
	"    return vector\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:copy()\n"
	"    return geometry.lineSegment.new(self.x1, self.y1, self.x2, self.y2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:unpack()\n"
	"    return self.x1, self.y1, self.x2, self.y2\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:length()\n"
	"    return math.sqrt((self.x1 - self.x2) ^ 2 + (self.y1 - self.y2) ^ 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:offset(dx, dy)\n"
	"    self.x1 = self.x1 + dx\n"
	"    self.y1 = self.y1 + dy\n"
	"    self.x2 = self.x2 + dx\n"
	"    self.y2 = self.y2 + dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:offsetBy(dx, dy)\n"
	"    return geometry.lineSegment.new(self.x1 + dx, self.y1 + dy, self.x2 + dx, self.y2 + dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:midPoint()\n"
	"    return geometry.point.new((self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:pointOnLine(distance, extend)\n"
	"    local length = self:length()\n"
	"    if not extend then\n"
	"        if distance < 0 then\n"
	"            distance = 0\n"
	"        else\n"
	"            distance = math.max(-length, math.min(length, distance))\n"
	"        end\n"
	"    end\n"
	"    local vecX = (self.x2 - self.x1) / length\n"
	"    local vecY = (self.y2 - self.y1) / length\n"
	"    return geometry.point.new(self.x1 + vecX * distance, self.y1 + vecY * distance)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:segmentVector()\n"
	"    return geometry.vector2D.new(self.x2 - self.x1, self.y2 - self.y1)\n"
	"end\n"
	"\n"
	"-- Based on: https://math.stackexchange.com/a/406895\n"
	"function playdate.geometry.lineSegment:closestPointOnLineToPoint(p)\n"
	"    local length = self:length()\n"
	"    local vecX = (self.x2 - self.x1) / length\n"
	"    local vecY = (self.y2 - self.y1) / length\n"
	"    local normX = -vecY\n"
	"    local normY = vecX\n"
	"    local offset = ((p.x - self.x1) * -normY + normX * (p.y - self.y1)) / (vecX * -normY + normX * vecY)\n"
	"    return geometry.point.new(self.x1 + offset * vecX, self.y1 + offset * vecY)\n"
	"end\n"
	"\n"
	"-- Based on: https://stackoverflow.com/a/1968345\n"
	"function playdate.geometry.lineSegment:intersectsLineSegment(ls)\n"
	"    local sx1 = self.x2 - self.x1\n"
	"    local sy1 = self.y2 - self.y1\n"
	"    local sx2 = ls.x2 - ls.x1\n"
	"    local sy2 = ls.y2 - ls.y1\n"
	"    local d = -sx2 * sy1 + sx1 * sy2\n"
	"    local s = (-sy1 * (self.x1 - ls.x1) + sx1 * (self.y1 - ls.y1)) / d\n"
	"    local t = (sx2 * (self.y1 - ls.y1) + sy2 * (self.x1 - ls.x1)) / d\n"
	"    if s >= 0 and s <= 1 and t >= 0 and t <= 1 then\n"
	"        return true, geometry.point.new(self.x1 + t * self.x2, self.y1 + t * self.y2)\n"
	"    else\n"
	"        return false\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment.fast_intersection(x1, y1, x2, y2, x3, y3, x4, y4)\n"
	"    local sx1 = x2 - x1\n"
	"    local sy1 = y2 - y1\n"
	"    local sx2 = x4 - x3\n"
	"    local sy2 = y4 - y3\n"
	"    local d = -sx2 * sy1 + sx1 * sy2\n"
	"    local s = (-sy1 * (x1 - x3) + sx1 * (y1 - y3)) / d\n"
	"    local t = (sx2 * (y1 - y3) + sy2 * (x1 - x3)) / d\n"
	"    if s >= 0 and s <= 1 and t >= 0 and t <= 1 then\n"
	"        return true, x1 + t * x2, y1 + t * y2\n"
	"    else\n"
	"        return false\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:intersectsPolygon(poly)\n"
	"    local points = {}\n"
	"    local count = 1\n"
	"    for i = 1, poly.numberOfVertices - 1 do\n"
	"        local intersects, x, y = geometry.lineSegment.fast_intersection(self.x1, self.y1, self.x2, self.y2, poly[i].x, poly[i].y, poly[i + 1].x, poly[i + 1].y)\n"
	"        if intersects then\n"
	"            points[count] = geometry.point.new(x, y)\n"
	"            count = count + 1\n"
	"        end\n"
	"    end\n"
	"    if count > 1 then\n"
	"        return true, points\n"
	"    else\n"
	"        return false\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:intersectsRect(rect)\n"
	"    local intersects, x, y\n"
	"    local points = {}\n"
	"    local i = 1\n"
	"    intersects, x, y = geometry.fast_intersection(self.x1, self.y1, self.x2, self.y2, rect.x, rect.y, rect.x + rect.width, rect.y)\n"
	"    if intersects then\n"
	"        points[i] = geometry.points.new(x, y)\n"
	"        i = i + 1\n"
	"    end\n"
	"    intersects, x, y = geometry.fast_intersection(self.x1, self.y1, self.x2, self.y2, rect.x, rect.y, rect.x, rect.y + rect.height)\n"
	"    if intersects then\n"
	"        points[i] = geometry.points.new(x, y)\n"
	"        i = i + 1\n"
	"    end\n"
	"    intersects, x, y = geometry.fast_intersection(self.x1, self.y1, self.x2, self.y2, rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height)\n"
	"    if intersects then\n"
	"        points[i] = geometry.points.new(x, y)\n"
	"        i = i + 1\n"
	"    end\n"
	"    intersects, x, y = geometry.fast_intersection(self.x1, self.y1, self.x2, self.y2, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height)\n"
	"    if intersects then\n"
	"        points[i] = geometry.points.new(x, y)\n"
	"        i = i + 1\n"
	"    end\n"
	"    if i > 1 then\n"
	"        return true, points\n"
	"    else\n"
	"        return false\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:__tostring()\n"
	"    return string.format('((%s, %s), (%s, %s))', self.x1, self.y1, self.x2, self.y2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.lineSegment:__eq(other)\n"
	"    return self.x1 == other.x1 and self.y1 == other.y1 and self.x2 == other.x2 and self.y2 == other.y2\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform.new(m11, m12, m21, m22, tx, ty)\n"
	"    local vector\n"
	"    if m11 == nil then\n"
	"        vector = {m11 = 1.0, m12 = .0, m21 = .0, m22 = 1.0, tx = .0, ty = .0}\n"
	"    else\n"
	"        vector = {m11 = m11 + .0, m12 = m12 + .0, m21 = m21 + .0, m22 = m22 + .0, tx = tx + .0, ty = ty + .0}\n"
	"    end\n"
	"    setmetatable(vector, geometry.affineTransform)\n"
	"    return vector\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:copy()\n"
	"    return playdate.geometry.affineTransform.new(self.m11, self.m12, self.m21, self.m22, self.tx, self.ty)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:invert()\n"
	"    local det = self.m11 * self.m22 - self.m12 * self.m21\n"
	"    local t_m11 = self.m22\n"
	"    local t_m12 = self.m12\n"
	"    local t_tx = self.m12 * self.ty - self.m22 * self.tx\n"
	"    local t_m21 = self.m21\n"
	"    local t_m22 = self.m11\n"
	"    local t_ty = self.m11 * self.ty - self.m21 * self.tx\n"
	"    self.m11 = t_m11 / det\n"
	"    self.m12 = -t_m12 / det\n"
	"    self.m21 = -t_m21 / det\n"
	"    self.m22 = t_m22 / det\n"
	"    self.tx = t_tx / det\n"
	"    self.ty = -t_ty / det\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:reset()\n"
	"    self.m11 = 1.0\n"
	"    self.m12 = 0.0\n"
	"    self.m21 = 0.0\n"
	"    self.m22 = 1.0\n"
	"    self.tx = 0.0\n"
	"    self.ty = 0.0\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:concat(af)\n"
	"    local t_m11 = af.m11 * self.m11 + af.m12 * self.m21\n"
	"    local t_m12 = af.m11 * self.m12 + af.m12 * self.m22\n"
	"    local t_tx = af.m11 * self.tx + af.m12 * self.ty + af.tx\n"
	"    local t_m21 = af.m21 * self.m11 + af.m22 * self.m21\n"
	"    local t_m22 = af.m21 * self.m12 + af.m22 * self.m22\n"
	"    local t_ty = af.m21 * self.tx + af.m22 * self.ty + af.ty\n"
	"    self.m11 = t_m11\n"
	"    self.m12 = t_m12\n"
	"    self.m21 = t_m21\n"
	"    self.m22 = t_m22\n"
	"    self.tx = t_tx\n"
	"    self.ty = t_ty\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:translate(dx, dy)\n"
	"    self.tx = self.tx + dx\n"
	"    self.ty = self.ty + dy\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:translatedBy(dx, dy)\n"
	"    return geometry.affineTransform.new(self.m11, self.m12, self.m21, self.m22, self.tx + dx, self.ty + dy)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:scale(sx, sy)\n"
	"    if sy == nil then\n"
	"        sy = sx\n"
	"    end\n"
	"    self.m11 = sx * self.m11\n"
	"    self.m12 = sx * self.m12\n"
	"    self.m21 = sy * self.m21\n"
	"    self.m22 = sy * self.m22\n"
	"    self.tx = sx * self.tx\n"
	"    self.ty = sy * self.ty\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:scaledBy(sx, sy)\n"
	"    if sy == nil then\n"
	"        sy = sx\n"
	"    end\n"
	"    return geometry.affineTransform.new(sx * self.m11, sx * self.m12, sy * self.m21, sy * self.m22, sx * self.tx, sy * self.ty)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:rotate(angle, x, y)\n"
	"    if x == nil then\n"
	"        x = 0\n"
	"        y = 0\n"
	"    elseif y == nil then\n"
	"        y = x.y\n"
	"        x = x.x\n"
	"    end\n"
	"    self.tx = self.tx - x\n"
	"    self.ty = self.ty - y\n"
	"    angle = angle / 180 * math.pi\n"
	"    local cos = math.cos(angle)\n"
	"    local sin = math.sin(angle)\n"
	"    local t_m11 = cos * self.m11 + -sin * self.m21\n"
	"    local t_m12 = cos * self.m12 + -sin * self.m22\n"
	"    local t_tx = cos * self.tx + -sin * self.ty\n"
	"    local t_m21 = sin * self.m11 + cos * self.m21\n"
	"    local t_m22 = sin * self.m12 + cos * self.m22\n"
	"    local t_ty = sin * self.tx + cos * self.ty\n"
	"    self.m11 = t_m11\n"
	"    self.m12 = t_m12\n"
	"    self.m21 = t_m21\n"
	"    self.m22 = t_m22\n"
	"    self.tx = t_tx + x\n"
	"    self.ty = t_ty + y\n"
	"end\n"
	"\n"
	"-- Official implementation doesn't respect geometry.point option here, for some reason\n"
	"function playdate.geometry.affineTransform:rotatedBy(angle, x, y)\n"
	"    local clone = self:copy()\n"
	"    clone:rotate(angle, x, y)\n"
	"    return clone\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:skew(sx, sy)\n"
	"    local tan_x = math.tan(sx / 180 * math.pi)\n"
	"    local tan_y = math.tan(sy / 180 * math.pi)\n"
	"    local t_m11 = self.m11 + tan_x * self.m21\n"
	"    local t_m12 = self.m12 + tan_x * self.m22\n"
	"    local t_tx = self.tx + tan_x * self.ty\n"
	"    local t_m21 = tan_y * self.m11 + self.m21\n"
	"    local t_m22 = tan_y * self.m12 + self.m22\n"
	"    local t_ty = tan_y * self.tx + self.ty\n"
	"    self.m11 = t_m11\n"
	"    self.m12 = t_m12\n"
	"    self.m21 = t_m21\n"
	"    self.m22 = t_m22\n"
	"    self.tx = t_tx\n"
	"    self.ty = t_ty\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:skewedBy(sx, sy)\n"
	"    local clone = self:copy()\n"
	"    clone:skew(sx, sy)\n"
	"    return clone\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformPoint(p)\n"
	"    local x = p.x * self.m11 + p.y * self.m12 + self.tx\n"
	"    local y = p.x * self.m21 + p.y * self.m22 + self.ty\n"
	"    p.x = x\n"
	"    p.y = y\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformedPoint(p)\n"
	"    return geometry.point.new(p.x * self.m11 + p.y * self.m12 + self.tx, p.x * self.m21 + p.y * self.m22 + self.ty)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformXY(x, y)\n"
	"    return x * self.m11 + y * self.m12 + self.tx, x * self.m21 + y * self.m22 + self.ty\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformLineSegment(ls)\n"
	"    ls.x1, ls.y1 = self:transformXY(ls.x1, ls.y1)\n"
	"    ls.x2, ls.y2 = self:transformXY(ls.x2, ls.y2)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformedLineSegment(ls)\n"
	"    local x1, y1 = self:transformXY(ls.x1, ls.y1)\n"
	"    local x2, y2 = self:transformXY(ls.x2, ls.y2)\n"
	"    return geometry.lineSegment.new(x1, y1, x2, y2)\n"
	"end\n"
	"\n"
	"-- Doesn't affect width and height in official implementation (Should it?)\n"
	"function playdate.geometry.affineTransform:transformAABB(r)\n"
	"    r.x, r.y = self:transformXY(r.x, r.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformedAABB(r)\n"
	"    local x, y = self:transformXY(r.x, r.y)\n"
	"    return geometry.rect.new(x, y, r.width, r.height)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:transformedPolygon(p)\n"
	"    local transformed = geometry.polygon.new(0)\n"
	"    transformed.numberOfVertices = p.numberOfVertices\n"
	"    for i = 1, p.numberOfVertices do\n"
	"        transformed[i] = self:transformedPoint(p[i])\n"
	"    end\n"
	"    return transformed\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:__tostring()\n"
	"    return string.format('[ %s    %s    %s ]\\n', self.m11, self.m12, self.tx)\n"
	"            .. string.format('[ %s    %s    %s ]\\n', self.m21, self.m22, self.ty)\n"
	"            .. string.format('[ %s    %s    %s ]\\n', 0.0, 0.0, 1.0)\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:__eq(other)\n"
	"    return self.m11 == other.m11 and self.m12 == other.m12 and self.m21 == other.m21 and self.m22 == other.m22 and self.tx == other.tx and self.ty == other.ty\n"
	"end\n"
	"\n"
	"function playdate.geometry.affineTransform:__mul(other)\n"
	"    if other.__name == 'playdate.geometry.affineTransform' then\n"
	"        local clone = self:copy()\n"
	"        clone:concat(other)\n"
	"        return clone\n"
	"    elseif other.__name == 'playdate.geometry.vector2D' then\n"
	"        return geometry.vector2D.new(other.dx * self.m11 + other.dy * self.m12 + self.tx, other.dx * self.m21 + other.dy * self.m22 + self.ty)\n"
	"    elseif other.__name == 'playdate.geometry.point' then\n"
	"        return geometry.point.new(other.x * self.m11 + other.y * self.m12 + self.tx, other.x * self.m21 + other.y * self.m22 + self.ty)\n"
	"    else\n"
	"       error('Invalid affineTransform __mul arg')\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon.new(...)\n"
	"    local count = select('#', ...)\n"
	"    local polygon = {}\n"
	"    setmetatable(polygon, geometry.polygon)\n"
	"    if count == 1 then\n"
	"        polygon.numberOfVertices = select(1, ...)\n"
	"        for i = 1, polygon.numberOfVertices do\n"
	"            polygon[i] = geometry.point.new(0, 0)\n"
	"        end\n"
	"    elseif type(select(1, ...)) == 'number' then\n"
	"        polygon.numberOfVertices = count / 2\n"
	"        for i = 1, count / 2 do\n"
	"            polygon[i] = geometry.point.new(select(i * 2 - 1, ...), select(i * 2, ...))\n"
	"        end\n"
	"    elseif select(1, ...).__name == 'playdate.geometry.point' then\n"
	"        polygon.numberOfVertices = count\n"
	"        for i = 1, count do\n"
	"            polygon[i] = select(i, ...)\n"
	"        end\n"
	"    else\n"
	"        error('polygon.new args')\n"
	"    end\n"
	"    return polygon\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:copy()\n"
	"    local polygon = {}\n"
	"    setmetatable(polygon, geometry.polygon)\n"
	"    for i = 1, self.numberOfVertices do\n"
	"        polygon[i] = self[i]\n"
	"    end\n"
	"    return polygon\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:close()\n"
	"    if self[self.numberOfVertices] ~= self[1] then\n"
	"        self[self.numberOfVertices + 1] = self[1]\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:isClosed()\n"
	"    return self[self.numberOfVertices] == self[1]\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:containsPoint(x, y, fillRule)\n"
	"    if type(x) ~= 'number' then -- A bit ugly, but nicer than the varargs syntax?\n"
	"        fillRule = y\n"
	"        y = x.y\n"
	"        x = x.x\n"
	"    end\n"
	"    if fillRule == nil or fillRule == graphics.kPolygonFillEvenOdd then -- Even-odd\n"
	"        -- Based on: https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n"
	"        local prev = self[self.numberOfVertices]\n"
	"        local c = false\n"
	"        for i = 1, self.numberOfVertices do\n"
	"            current = self[i]\n"
	"            if x == current.x and y == current.y then -- Is corner\n"
	"                return true\n"
	"            end\n"
	"            if (current.y > y) ~= (prev.y > y) then\n"
	"                local slope = (x - current.x) * (prev.y - current.y) - (prev.x - current.x) * (y - current.y)\n"
	"                if slope == 0 then -- On boundary\n"
	"                    return true\n"
	"                end\n"
	"                if (slope < 0) ~= (prev.y < current.y) then\n"
	"                    c = not c\n"
	"                end\n"
	"            end\n"
	"            prev = current\n"
	"        end\n"
	"        return c\n"
	"    else -- Non-zero (Winding number algorithm)\n"
	"        -- Based on: https://github.com/anirudhtopiwala/OpenSource_Problems/blob/master/Point_In_Polygon/src/point_in_polygon.cpp\n"
	"        local count = 0\n"
	"        for i = 1, self.numberOfVertices - 1 do -- Todo: Is the last vertex an issue when closed/unclosed?\n"
	"            local p1 = self[i]\n"
	"            local p2 = self[i + 1]\n"
	"            local pointInLine = ((y - p1.y) * (p2.x - p1.x)) - ((x - p1.x) * (p2.y - p1.y))\n"
	"            if pointInLine == 0 then -- Lies on polygon\n"
	"                return true\n"
	"            end\n"
	"            if p1.y <= y then\n"
	"                if p2.y > y then -- Upward crossing\n"
	"                    if pointInLine > 0 then -- Point is left of edge\n"
	"                        count = count + 1\n"
	"                    end\n"
	"                end\n"
	"            else\n"
	"                if p2.y < y then -- Downward crossing\n"
	"                    if pointInLine < 0 then -- Point is right of edge\n"
	"                        count = count - 1\n"
	"                    end\n"
	"                end\n"
	"            end\n"
	"        end\n"
	"        return count ~= 0\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:getBounds()\n"
	"    local minX = 0\n"
	"    local minY = 0\n"
	"    local maxX = 0\n"
	"    local maxY = 0\n"
	"    for i = 0, self.numberOfVertices do\n"
	"        local p = self[i]\n"
	"        minX = math.min(minX, p.x)\n"
	"        minY = math.min(minY, p.y)\n"
	"        maxX = math.max(maxX, p.x)\n"
	"        maxY = math.max(maxY, p.y)\n"
	"    end\n"
	"    return minX, minY, maxX, maxY\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:getBoundsRect()\n"
	"    local minX, minY, maxX, maxY = self:getBounds()\n"
	"    return geometry.rect.new(minX, minY, maxX - minX, maxY - minY)\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:count()\n"
	"    if self[self.numberOfVertices] ~= self[1] then\n"
	"        return self.numberOfVertices\n"
	"    else\n"
	"        return self.numberOfVertices - 1\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:length()\n"
	"    local length = 0\n"
	"    for i = 1, self.numberOfVertices - 1 do\n"
	"        length = length + self[i]:distanceToPoint(self[i + 1])\n"
	"    end\n"
	"    return length\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:setPointAt(n, x, y)\n"
	"    self[n].x = x\n"
	"    self[n].y = y\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:getPointAt(n)\n"
	"    return self[n]\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:intersects(p)\n"
	"    for i = 1, self.numberOfVertices - 1 do\n"
	"        for j = 1, p.numberOfVertices - 1 do\n"
	"            local s1 = self[i]\n"
	"            local e1 = self[i + 1]\n"
	"            local s2 = p[j]\n"
	"            local e2 = p[j + 1]\n"
	"            if geometry.lineSegment.fast_intersection(s1.x, s1.y, e1.x, e1.y, s2.x, s2.y, e2.x, e2.y) then\n"
	"                return true\n"
	"            end\n"
	"        end\n"
	"    end\n"
	"    return false\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:pointOnPolygon(distance, extend)\n"
	"    if self.numberOfVertices < 2 then\n"
	"        return nil -- Todo: What should be returned for empty polygon?\n"
	"    end\n"
	"    local traveled = 0\n"
	"    for i = 1, self.numberOfVertices - 1 do\n"
	"        local len = self[i]:distanceToPoint(self[i + 1])\n"
	"        if traveled + len >= distance then\n"
	"            return geometry.lineSegment.new(self[i].x, self[i].y, self[i + 1].x, self[i + 1].y):pointOnLine(distance - traveled)\n"
	"        else\n"
	"            traveled = traveled + len\n"
	"        end\n"
	"    end\n"
	"    if extend then\n"
	"        local segment = geometry.lineSegment.new(self[self.numberOfVertices - 1].x, self[self.numberOfVertices - 1].y, self[self.numberOfVertices].x, self[self.numberOfVertices].y)\n"
	"        return segment:pointOnLine(distance - traveled)\n"
	"    else\n"
	"        return self[self.numberOfVertices]:copy()\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:translate(dx, dy)\n"
	"    for i = 1, self.numberOfVertices do\n"
	"        local point = self[i]\n"
	"        point.x = point.x + dx\n"
	"        point.y = point.y + dy\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:__mul(t)\n"
	"    for i = 1, self.numberOfVertices do\n"
	"        t:transformPoint(self[i])\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:__eq(other)\n"
	"    if self.numberOfVertices ~= other.numberOfVertices then\n"
	"        return false\n"
	"    end\n"
	"    for i = 1, self.numberOfVertices do\n"
	"        if self[i] ~= other[i] then\n"
	"            return false\n"
	"        end\n"
	"    end\n"
	"    return true\n"
	"end\n"
	"\n"
	"function playdate.geometry.polygon:__tostring()\n"
	"    local string = '['\n"
	"    for i = 1, self.numberOfVertices do\n"
	"        if i > 1 then\n"
	"            string = string .. ', '\n"
	"        end\n"
	"        string = string .. tostring(self[i])\n"
	"    end\n"
	"    return string .. ']'\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc.new(x, y, radius, startAngle, endAngle, direction)\n"
	"    if direction == nil then\n"
	"        direction = endAngle > startAngle\n"
	"    end\n"
	"    local arc = {x = x + .0, y = y + .0, radius = radius + .0, startAngle = startAngle + .0, endAngle = endAngle + .0, direction = direction}\n"
	"    setmetatable(arc, geometry.arc)\n"
	"    return arc\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:copy()\n"
	"    return playdate.geometry.arc.new(self.x, self.y, self.radius, self.startAngle, self.endAngle, self.direction)\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:length()\n"
	"    return 2 * math.pi * self.radius * math.abs(self.startAngle - self.endAngle) / 360\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:isClockwise()\n"
	"    return self.direction;\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:setIsClockwise(flag)\n"
	"    self.direction = flag\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:pointOnArc(distance, extend)\n"
	"    local angle = distance / (2 * math.pi * self.radius) * 360\n"
	"    if not self.direction then\n"
	"        angle = -angle\n"
	"    end\n"
	"\n"
	"    if not extend then\n"
	"        local length = math.abs(self.endAngle - self.startAngle)\n"
	"        if distance < 0 then\n"
	"            angle = 0\n"
	"        else\n"
	"            angle = math.max(math.min(angle, length), -length)\n"
	"        end\n"
	"    end\n"
	"\n"
	"    angle = (self.startAngle + angle -90) / 180 * math.pi\n"
	"    return geometry.point.new(math.cos(angle) * self.radius + self.x, math.sin(angle) * self.radius + self.y)\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:__tostring()\n"
	"    return string.format('location: (%s, %s), radius: %s, startAngle: %s, endAngle: %s, clockwise? %s', self.x, self.y, self.radius, self.startAngle, self.endAngle, self.direction)\n"
	"end\n"
	"\n"
	"function playdate.geometry.arc:eq(other)\n"
	"    return self.x == other.x and self.y == other.y and self.radius == other.radius\n"
	"            and self.startAngle == other.startAngle and self.endAngle == other.endAngle and self.direction == other.direction\n"
	"end\n"
	"\n"
	"function playdate.geometry.squaredDistanceToPoint(x1, y1, x2, y2)\n"
	"    return (x1 - x2) ^ 2 + (y1 - y2) ^ 2\n"
	"end\n"
	"\n"
	"function playdate.geometry.distanceToPoint(x1, y1, x2, y2)\n"
	"    return math.sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2)\n"
	"end\n"
	"\n"
	"-- Unpack object args for official library functions that expect userdata rather than table objects\n"
	"local drawCircleInRect = playdate.graphics.drawCircleInRect\n"
	"local fillCircleInRect = playdate.graphics.fillCircleInRect\n"
	"local drawCircleAtPoint = playdate.graphics.drawCircleAtPoint\n"
	"local fillCircleAtPoint = playdate.graphics.fillCircleAtPoint\n"
	"local drawArc = playdate.graphics.drawArc\n"
	"local drawTextInRect = playdate.graphics.drawTextInRect\n"
	"local drawLocalizedTextInRect = playdate.graphics.drawLocalizedTextInRect\n"
	"local addEmptyCollisionSprite = spritelib.addEmptyCollisionSprite\n"
	"local drawInRect = playdate.graphics.nineSlice.drawInRect\n"
	"\n"
	"function playdate.graphics.drawCircleInRect(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawCircleInRect(x.x, x.y, x.width, x.height)\n"
	"    else\n"
	"        drawCircleInRect(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.fillCircleInRect(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        fillCircleInRect(x.x, x.y, x.width, x.height)\n"
	"    else\n"
	"        fillCircleInRect(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.drawCircleAtPoint(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawCircleAtPoint(x.x, x.y, select(1, ...))\n"
	"    else\n"
	"        drawCircleAtPoint(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.fillCircleAtPoint(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        fillCircleAtPoint(x.x, x.y, select(1, ...))\n"
	"    else\n"
	"        fillCircleAtPoint(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.drawArc(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawArc(x.x, x.y, x.radius, x.startAngle, x.endAngle, select(1, ...))\n"
	"    else\n"
	"        drawArc(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.drawTextInRect(str, x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawTextInRect(str, x.x, x.y, x.width, x.height, select(1, ...))\n"
	"    else\n"
	"        drawTextInRect(str, x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.drawLocalizedTextInRect(text, x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawLocalizedTextInRect(text, x.x, x.y, x.width, x.height, select(1, ...))\n"
	"    else\n"
	"        drawLocalizedTextInRect(text, x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function spritelib.addEmptyCollisionSprite(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        addEmptyCollisionSprite(x.x, x.y, x.width, x.height, select(1, ...))\n"
	"    else\n"
	"        addEmptyCollisionSprite(x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"\n"
	"function playdate.graphics.nineSlice:drawInRect(x, ...)\n"
	"    if type(x) == 'table' then\n"
	"        drawInRect(self, x.x, x.y, x.width, x.height)\n"
	"    else\n"
	"        drawInRect(self, x, select(1, ...))\n"
	"    end\n"
	"end\n"
	"";
